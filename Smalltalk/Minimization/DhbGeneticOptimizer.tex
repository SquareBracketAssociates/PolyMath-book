$$\halign{ #\hfil&\quad#\hfil\cr {\sl Class}& {\Large\bf DhbGeneticOptimizer}\cr
{\sl Subclass of }&{\tt DhbFunctionOptimizer}\cr\noalign{\vskip 1ex}

{\sl Instance variable names:}&\parbox[t]{4 in}{\tt  chromosomeManager }\cr\noalign{\vskip 1ex}}$$


Class methods
{\parskip 1ex\par\noindent}
{\bf defaultMaximumIterations}
\begin{verbatim}
    ^500

\end{verbatim}
{\bf defaultPrecision}
\begin{verbatim}
    ^0

\end{verbatim}



Instance methods
{\parskip 1ex\par\noindent}
{\bf chromosomeManager:} {\tt aChromosomeManager}
\begin{verbatim}
    chromosomeManager := aChromosomeManager.
    ^self

\end{verbatim}
{\bf collectPoints}
\begin{verbatim}
    | bestPoint |
    bestPoints notEmpty
        ifTrue: [ bestPoint := bestPoints removeFirst].
    bestPoints removeAll: bestPoints asArray.
    chromosomeManager population do: [:each | self addPointAt: each].
    bestPoint notNil
        ifTrue: [ bestPoints add: bestPoint].
    result := bestPoints first position.

\end{verbatim}
{\bf computePrecision}
\begin{verbatim}
    ^1

\end{verbatim}
{\bf evaluateIteration}
\begin{verbatim}
    | randomScale |
    randomScale := self randomScale.
    chromosomeManager reset.
    [ chromosomeManager isFullyPopulated]
        whileFalse: [ self processRandomParents: randomScale].
    self collectPoints.
    ^self computePrecision

\end{verbatim}
{\bf initializeIterations}
\begin{verbatim}
    chromosomeManager randomnizePopulation.
    self collectPoints

\end{verbatim}
{\bf processRandomParents:} {\tt aNumberArray}
\begin{verbatim}
    chromosomeManager process: ( bestPoints at: ( self randomIndex: 
                                               aNumberArray)) position
                        and:  ( bestPoints at: ( self randomIndex: 
                                              aNumberArray)) position.

\end{verbatim}
{\bf randomIndex:} {\tt aNumberArray}
\begin{verbatim}
    | x n |
    x := Number random.
    n := 1.
    aNumberArray do: 
        [ :each |
          x < each
            ifTrue: [ ^n].
          n := n + 1.
        ].
    ^aNumberArray size  

\end{verbatim}
{\bf randomScale}
\begin{verbatim}
    | norm fBest fWorst answer|
    fBest := bestPoints first value.
    fWorst := bestPoints last value.
    norm := 1 / ( fBest - fWorst).
    answer := bestPoints collect: [ :each | (each value - fWorst) * 
                                                                norm].
    norm := 1 / ( answer inject: 0 into: [ :sum :each | each + sum]).
    fBest := 0.
    ^answer collect: [ :each | fBest := each * norm + fBest. fBest]

\end{verbatim}

